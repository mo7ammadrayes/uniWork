\documentclass{article}
\usepackage{graphicx} 
\usepackage{listings}
\usepackage{minted}

\usepackage{amsmath}
\usepackage{float} % 
\title{COMP1204: Data Management \\ Coursework two }
% Update these!
\author{Mohammad Rayes \\35316004}\date{May 2024}

\begin{document}

\maketitle
\newpage
\section{The Relational Model}
\subsection{EX1} 
\begin{table}[H] % Use the float package specifier [H] for strict placement
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Attribute}                & \textbf{SQLite Data Type} \\ \hline
dateRep                           & TEXT                      \\ \hline
day                               & INTEGER                   \\ \hline
month                             & INTEGER                   \\ \hline
year                              & INTEGER                   \\ \hline
cases                             & INTEGER                   \\ \hline
deaths                            & INTEGER                   \\ \hline
countriesAndTerritories           & TEXT                      \\ \hline
geoId                             & TEXT                      \\ \hline
countryterritoryCode              & TEXT                      \\ \hline
popData2020                       & INTEGER                   \\ \hline
continentExp                      & TEXT                      \\ \hline
\end{tabular}
\caption{Attributes and SQLite Data Types in the Dataset}
\end{table}
\subsection{EX2}
\subsubsection{Minimal Set of Functional Dependencies}

The minimal functional dependencies for the dataset, assuming unique identification of records by combinations of date and geographical identifiers, are as follows:
\begin{enumerate}
    \item \( \text{dateRep} \rightarrow \text{day} \)
    \item \( \text{dateRep} \rightarrow \text{month} \)
    \item \( \text{dateRep} \rightarrow \text{year} \)
    \item \( \text{geoId} \rightarrow \text{countriesAndTerritories} \)
    \item \( \text{geoId} \rightarrow \text{countryterritoryCode} \)
    \item \( \text{geoId} \rightarrow \text{continentExp} \)
    \item \( \text{geoId} \rightarrow \text{popData2020} \)
    \item \( (\text{dateRep}, \text{geoId}) \rightarrow \text{cases} \)
    \item \( (\text{dateRep}, \text{geoId}) \rightarrow \text{deaths} \)
\end{enumerate}
\newpage

\textbf{Assumptions and Justifications:}
\begin{itemize}
    \item \textit{Uniqueness of geoId:} Assumed that each \texttt{geoId} uniquely identifies a set of static attributes about a location (country, population, continent), which is common in datasets containing geographical information.
    \item \textit{Stability of dateRep:} The representation of a date as \texttt{dateRep} is assumed to uniquely determine its day, month, and year components, typical for date formatting in data systems.
    \item \textit{Combination keys for dynamic data:} The combination of \texttt{dateRep} and \texttt{geoId} is assumed necessary and sufficient to determine the counts of cases and deaths, reflecting the nature of reporting in epidemiological data where each entry represents a unique event/day/location.
    \item \textit{Treatment of nulls and blanks:} It is assumed that all entries are complete and any nulls would be addressed prior to applying these dependencies, as incompleteness would violate the principles of functional dependency.
\end{itemize}


\subsection{EX3}
Based on the provided functional dependencies, several combinations of attributes are considered to explore their eligibility as candidate keys. Each candidate key must be minimal and able to uniquely identify every tuple in the dataset.

\subsubsection{Explored Combinations}
\begin{enumerate}
    \item \( (\text{dateRep}, \text{geoId}) \)
    
    
    \item \( (\text{dateRep}, \text{countryterritoryCode}) \)
   
    \item \( (\text{day}, \text{month}, \text{year}, \text{geoId}) \)
   
    
    \item \( (\text{geoId}, \text{day}, \text{month}, \text{year}, \text{cases}, \text{deaths}) \)
\end{enumerate}

\subsection{EX4}

After evaluating potential candidate keys, \textbf{\( (\text{dateRep}, \text{geoId}) \)} is chosen as the primary key for the dataset for the following reasons:

\begin{itemize}
    \item \textbf{Simplicity and Minimality} 
    \item \textbf{Comprehensive Coverage}
    \item \textbf{Practicality in Usage}
\end{itemize}

This key not only fulfills the requirements of a candidate key but also aligns with the practical needs of database management and data integrity maintenance.

\section{Normalisation}
\subsection{EX5}
Identified partial-key dependencies from established functional dependencies illustrate that specific attributes rely solely on parts of a potential composite key. This necessitates additional relations for normalization adherence:
\begin{itemize}
    \item \( \text{dateRep} \rightarrow \text{day, month, year} \): Suggests a separate relation for date components derived directly from the reporting date.
    \item \( \text{geoId} \rightarrow \text{countryterritoryCode, countriesAndTerritories,continentExp, popData2020} \): Indicates the need for a dedicated geographical information table.
\end{itemize}
Resulting relations:
\begin{enumerate}
    \item \textbf{Date Information Table}: Includes \( \text{dateRep, day, month, year} \).
   \item \textbf{Geographic Details Table}: Contains \( \text{geoId, countryterritoryCode,} \\
\text{countriesAndTerritories, continentExp, popData2020} \).

\end{enumerate}
This decomposition aligns with the principles of the Second Normal Form (2NF).

\subsection{EX6}
To achieve 2NF, we decomposed the original dataset into three tables, eliminating partial-key dependencies and ensuring full dependency on primary keys:
\begin{itemize}
    \item \textbf{Date Information}: Holds date-related attributes, isolated to prevent partial-key dependencies. Fields include \( \text{dateRep} \) (TEXT), \( \text{day} \) (INTEGER), \( \text{month} \) (INTEGER), \( \text{year} \) (INTEGER). Primary Key: \( \text{dateRep} \).
    \item \textbf{Geographic Information}: Consolidates geographic details, ensuring clean structure. Fields include \( \text{geoId} \) (TEXT), \( \text{countryterritoryCode} \) (TEXT), \text{countriesAndTerritories} \) (TEXT),\( \text{continentExp} \) (TEXT), \( \text{popData2020} \) (INTEGER). Primary Key: \( \text{geoId} \).
    \item \textbf{Case and Death Records}: Captures cases and deaths linked to dates and locations. Fields include \( \text{dateRep} \) (TEXT), \( \text{geoId} \) (TEXT), \( \text{cases} \) (INTEGER), \( \text{deaths} \) (INTEGER). Primary Key: \( \text{(dateRep, geoId)} \).
\end{itemize}
These tables ensure data integrity by reducing redundancy.

\subsection{EX7}
No transitive dependencies are present in the new relations, complying with 2NF and 3NF principles.

\subsection{EX8}
Our relations inherently satisfy the requirements of 3NF as they are free from transitive dependencies and each attribute is fully functionally dependent on the primary key(s).

\subsection{EX9}
The relations conform to Boyce-Codd Normal Form (BCNF), ensuring no anomalies or redundancy:
\begin{itemize}
    \item \textbf{Date Information Table}: All attributes are functionally dependent solely on \( \text{dateRep} \), the primary key.
    \item \textbf{Geographic Information Table}: Attributes are functionally dependent solely on \( \text{geoId} \), the primary key.
    \item \textbf{Case and Death Records Table}: \( \text{cases} \) and \( \text{deaths} \) depend only on the composite key \( \text{(dateRep, geoId)} \).
\end{itemize}
Thus, the relations are in BCNF, ensuring robust data integrity.
\section{Modelling}
\subsection{EX10}

To import a raw dataset into SQLite and create a dump file, follow these streamlined steps:

\begin{enumerate}
    \item \textbf{Start SQLite}: Launch SQLite with your database.
    \begin{lstlisting}[language=bash]
    sqlite3 coronavirus.db
    \end{lstlisting}

    \item \textbf{Create the Table}: Set up the dataset schema.
    \begin{lstlisting}[language=SQL]
    CREATE TABLE dataset (
        dateRep TEXT,
        day INTEGER,
        month INTEGER, 
        year INTEGER, 
        cases INTEGER,
        deaths INTEGER, 
        countriesAndTerritories TEXT,
        geoId TEXT, 
        countryterritoryCode TEXT,
        popData2020 INTEGER, 
        continentExp TEXT);
    \end{lstlisting}

    \item \textbf{Set CSV Mode}: Configure SQLite for CSV data.
    \begin{lstlisting}[language=SQL]
    .mode csv
    \end{lstlisting}

    \item \textbf{Import the Dataset}: Ensure CSV columns align with your table schema.
    \begin{lstlisting}[language=SQL]
    .import dataset.csv dataset
    \end{lstlisting}

    \item \textbf{Prepare for Dumping}: Specify the output file for the SQL dump.
    \begin{lstlisting}[language=SQL]
    .output dataset.sql
    \end{lstlisting}

    \item \textbf{Dump the Dataset}: Export the schema and data to an SQL file.
    \begin{lstlisting}[language=SQL]
    .dump
    \end{lstlisting}
\end{enumerate}

\subsection{EX11}

\begin{minted}[linenos, breaklines, fontsize=\footnotesize]{sql}
-- Table: Date Information
CREATE TABLE IF NOT EXISTS Date_Information (
    dateRep TEXT PRIMARY KEY NOT NULL,
    day INTEGER NOT NULL,
    month INTEGER NOT NULL,
    year INTEGER NOT NULL
);

-- Table: Geographic Information
CREATE TABLE IF NOT EXISTS Geographic_Information (
    geoId TEXT PRIMARY KEY NOT NULL,
    countryterritoryCode TEXT NOT NULL,
    countriesAndTerritories TEXT NOT NULL,
    continentExp TEXT NOT NULL,
    popData2020 INTEGER
);

-- Table: Case and Death Records
CREATE TABLE IF NOT EXISTS Case_Death_Records (
    dateRep TEXT NOT NULL,
    geoId TEXT NOT NULL,
    cases INTEGER,
    deaths INTEGER,
    PRIMARY KEY (dateRep, geoId)
);
\end{minted}

\subsection{EX12}

\begin{minted}[linenos, breaklines, fontsize=\footnotesize]{sql}
-- Insert data into Date Information Table
INSERT OR IGNORE INTO Date_Information (dateRep, day, month, year)
SELECT dateRep, day, month, year
FROM dataset;

-- Insert data into Geographic Information Table
INSERT OR IGNORE INTO Geographic_Information (geoId,countriesAndTerritories ,countryterritoryCode, continentExp, popData2020)
SELECT geoId,countriesAndTerritories ,countryterritoryCode, continentExp, popData2020
FROM dataset;

-- Insert data into Case and Death Records Table
INSERT OR IGNORE INTO Case_Death_Records (dateRep, geoId, cases, deaths)
SELECT dateRep, geoId, cases, deaths
FROM dataset;
\end{minted}
\subsection{EX13}

To verify the functionality of the SQL scripts, the following commands were executed:

\begin{minted}[linenos, breaklines, fontsize=\footnotesize]{bash}
sqlite3 coronavirus.db < dataset.sql
sqlite3 coronavirus.db < ex11.sql
sqlite3 coronavirus.db < ex12.sql
\end{minted}

All of these tests were successful and executed without errors.
\section{Querying}
\subsection{EX14}


\begin{minted}[
    linenos,
    breaklines,
    fontsize=\footnotesize
]{sql}
SELECT 
    SUM(cases) AS total_cases,
    SUM(deaths) AS total_deaths
FROM 
    Case_Death_Records;
\end{minted}
\subsection{EX15}
\begin{minted}[
    linenos,
    breaklines,
    fontsize=\footnotesize
]{sql}
    SELECT Date_Information.dateRep AS Date_Reported,
       Case_Death_Records.cases AS Number_of_Cases
FROM Case_Death_Records
INNER JOIN Date_Information ON Case_Death_Records.dateRep = Date_Information.dateRep
INNER JOIN Geographic_Information ON Case_Death_Records.geoId = Geographic_Information.geoId
WHERE Geographic_Information.countryterritoryCode = 'GBR'
ORDER BY Date_Information.year, Date_Information.month, Date_Information.day ASC;
\end{minted}
\subsection{EX16}
\begin{minted}[
    linenos,
    breaklines,
    fontsize=\footnotesize
]{sql}
  SELECT
    g.countriesAndTerritories AS CountryName, 
    d.dateRep AS Date,
    cd.cases AS Cases,
    cd.deaths AS Deaths
FROM
    Case_Death_Records cd
JOIN
    Geographic_Information g ON cd.geoId = g.geoId
JOIN
    Date_Information d ON cd.dateRep = d.dateRep
ORDER BY
    d.year ASC, d.month ASC, d.day ASC, g.countriesAndTerritories ASC;
\end{minted}
\subsection{EX17}
\begin{minted}[
    linenos,
    breaklines,
    fontsize=\footnotesize
]{sql}
   SELECT
    g.countriesAndTerritories AS CountryName,
    ROUND(SUM(cd.cases) * 100.0 / g.popData2020, 2) AS Cases_Percentage,
    ROUND(SUM(cd.deaths) * 100.0 / g.popData2020, 2) AS Deaths_Percentage
FROM
    Case_Death_Records cd
JOIN
    Geographic_Information g ON cd.geoId = g.geoId
GROUP BY
    g.countriesAndTerritories
\end{minted}
\subsection{EX18}
\begin{minted}[
    linenos,
    breaklines,
    fontsize=\footnotesize
]{sql}
    SELECT
    g.countriesAndTerritories AS "Country Name",
    ROUND((SUM(cd.deaths) * 100.0 / SUM(cd.cases)), 2) AS "Percentage Deaths of Country Cases (%)"
FROM
    Case_Death_Records cd
JOIN
    Geographic_Information g ON cd.geoId = g.geoId
GROUP BY
    g.countriesAndTerritories
HAVING
    SUM(cd.cases) > 0  -- To prevent division by zero
ORDER BY
    "Percentage Deaths of Country Cases (%)" DESC
LIMIT 10;
\end{minted}
\subsection{EX19}
\begin{minted}
[
    linenos,
    breaklines,
    fontsize=\footnotesize
]{sql}   
SELECT
    d.dateRep AS "Date",
    SUM(cd.cases) OVER (ORDER BY d.year, d.month, d.day) AS "Cumulative UK Cases",
    SUM(cd.deaths) OVER (ORDER BY d.year, d.month, d.day) AS "Cumulative UK Deaths"
FROM
    Case_Death_Records cd
JOIN
    Geographic_Information g ON cd.geoId = g.geoId
JOIN
    Date_Information d ON cd.dateRep = d.dateRep
WHERE
    g.countriesAndTerritories = 'United_Kingdom'
ORDER BY
    d.year, d.month, d.day;
\end{minted}
\end{document}



